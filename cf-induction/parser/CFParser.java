/* Generated By:JavaCC: Do not edit this line. CFParser.java */
/*
 * $Id$ 
 */

package parser;

import java.io.File;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;

import ki.Schema;
import ki.Clause;
import ki.CFProblem;
import ki.SymbolTable;
import ki.TermTable;
import ki.ClauseKind;
import ki.Pair;
import ki.MSchema;
import ki.Mode;
import ki.Type;
import ki.InductionField;

/**
 * 仮説発見問題 (CFProblem) 構文解析クラス
 */
public final class CFParser implements CFParserConstants {

  /**
   * 仮説発見問題の構文解析クラスを生成する
   * @param fileName 構文解析するファイル名
   */
  private CFParser(String fileName) throws FileNotFoundException
  {
    this(new BufferedReader(new FileReader(fileName)));

    // 構文解析中のファイル名を保存（エラー出力用）
    this.fileName = new File(fileName).getName();
    // 仮説発見問題の名前とする
    this.problemName = fileName;
  }

  /**
   * 指定のファイルを解析し，仮説発見問題を生成する
   * @param fileName 構文解析するファイル名
   */
  public static CFProblem parse(String fileName)
  {
    try {
      // 構文解析器生成
      CFParser parser = new CFParser(fileName);
      // 仮の仮説発見問題
      CFP cfp = new CFP();
      // 構文解析の実行
      parser.parse(cfp);

      return new CFProblem(parser.problemName,
                                           cfp.getInputClauses(),
                                           cfp.getInputModes(),
                                                                         cfp.getInductionField(),
                                                                      cfp.getInputTypes());


    } catch (FileNotFoundException e) {
      System.err.println(e.getMessage());
      System.exit(-1);
    }

    return null;    // ここにくることはない
  }

  /**
   * 指定のファイルリストを解析し，仮説発見問題を生成する
   * @param fileNames 構文解析するファイル名のリスト
   */
  public static CFProblem parse(List fileNames)
  {
    try {
      // 問題の名前
      String problemName = null;
      // 仮の仮説発見問題
      CFP cfp = new CFP();

      // すべてのファイルを解析
      for (int i=0; i < fileNames.size(); i++) {
        String fileName = (String)fileNames.get(i);
        // 構文解析器生成
        CFParser parser = new CFParser(fileName);
        // 構文解析
        parser.parse(cfp);

        // 先頭のファイルの名前を問題名とする
        if (problemName == null)
          problemName = parser.problemName;
      }

      return new CFProblem(problemName,
                                           cfp.getInputClauses(),
                                           cfp.getInputModes(),
                                                                         cfp.getInductionField(),
                                                                         cfp.getInputTypes());
    } catch (FileNotFoundException e) {
      System.err.println(e.getMessage());
      System.exit(-1);
    }

    return null;    // ここにくることはない
  }

  /**
   * 仮説発見問題を構文解析する
   * @param cfp 仮の仮説発見問題
   */
  public void parse(CFP cfp)
  {
    try {
      problem(cfp);
    } catch (ParseException e) {
                        System.err.println(fileName + ": " + e.getMessage());
      System.exit(1);
    }
  }

  /**
   * 仮説発見問題を構文解析する（ストリームをコンストラクタに渡した場合に利用するメソッド）
   * @return 仮説発見問題
   */
  public CFProblem parse()
  {
      // 仮の仮説発見問題
      CFP cfp = new CFP();
      // 構文解析の実行
      parse(cfp);

      return new CFProblem(problemName,
                                           cfp.getInputClauses(),
                                           cfp.getInputModes(),
                                                                         cfp.getInductionField(),
                                                                               cfp.getInputTypes());
  }

  /**
   * 検査用 main 関数
   * @param arg[] コマンド行引数の配列
   */
  static public void main(String[] args)
  {
    try {
                        if ( args.length == 1 ) {
        System.out.println(parse(args[0]));
      }
                        else {
        System.out.println("Usage: java parser.CFParser problem.cf");
      }
                } catch (Exception e) {
                        e.printStackTrace();
                }
  }

  /**
   * 複数ファイルを解析するために，入力節集合，生成領域，探索戦略を保持するクラス
   */
  private static final class CFP {

    /**
     * 入力節を追加する
     * @param c 入力節
     */
    public void addInputClause(Clause c)
    {
      inputClauses.add(c);
    }

    /**
     * 入力節集合を取得する
     * @return 入力節集合
     */
    public LinkedList getInputClauses()
    {
      return inputClauses;
    }

    /**
 	 * 宣言を追加する
	 * @param mode 入力宣言
     */
        public void addInputMode(Mode mode)
        {
                inputModes.add(mode);
        }

        /**
	 * 宣言集合を取得する
	 * @return 宣言集合
	 */
        public LinkedList getInputModes()
        {
                return inputModes;
        }


   /**
 	 * タイプを追加する
	 * @param type 入力タイプ
     */
        public void addInputTypes(Pair pair)
        {
                inputTypes.add(pair);
        }

        /**
	 * タイプ集合を取得する
	 * @return タイプ集合
	 */
        public Type getInputTypes()
        {
                return inputTypes;
        }


  /**
     * 仮説発見領域を登録する（上書きするので注意）
     * @param inductionField 登録する仮説発見領域
     */
    public void setInductionField(InductionField inductionField)
    {
      this.inductionField = inductionField;
    }

    /**
     * 仮説発見領域を取得する
     * @return 仮説発見領域
     */
    public InductionField getInductionField()
    {
      return inductionField;
    }



    /** 入力節集合 */
    private LinkedList<Clause> inputClauses = new LinkedList<Clause>();
    /** 宣言集合 */
    private LinkedList<Mode> inputModes = new LinkedList<Mode>();
        /** タイプテーブル */
    private Type inputTypes = new Type();
    /** 仮説発見領域 */
    private InductionField inductionField = null;

  }

  /**
   * 節内の変数名を管理するためだけのテーブル
   */
  private static final class VarNameTable {

    /**
     * 変数を登録する
     * @param name 登録する変数
     * @return 変数番号
     */

    public int put(String name)
    {
      //System.out.println("name is"+name);
      // 検索
      int id = startID;
      names[maxID + 1] = name;    // 番兵
      while (!names[id].equals(name))
        id++;

      // 登録済み？
      if ((maxID + 1) != id)
        return id;

      // 新規登録
      maxID++;

      // 配列のサイズを増やしておく
      if (names.length == maxID + 2) {
        String[] dest = new String[ names.length * 2 ];
        System.arraycopy(names, 0, dest, 0, names.length);
        names = dest;
      }

      return maxID;
    }

    /**
     * 無名変数を登録する
     * @return 変数番号
     */
    public int put()
    {
      // 新規登録
      maxID++;
      names[maxID] = "_";

      // 配列のサイズを増やしておく
      if (names.length == maxID + 2) {
        String[] dest = new String[ names.length * 2 ];
        System.arraycopy(names, 0, dest, 0, names.length);
        names = dest;
      }

      return maxID;
    }

    public String getVariable(int id) {
                String varName = names[id];
                return varName;
    }


    /**
     * 登録されている変数の数を返す
     * @return 登録されている変数の数
     */
    public int size()
    {
      return maxID + 1;
    }

    /**
     * 変数テーブルをクリアする
     */
    public void clear()
    {
      startID = maxID +1;
    }

    /**
     * このオブジェクトを表す文字列を取得する
     * @return このオブジェクトを表す文字列
     */
    public String toString()
    {
      StringBuffer str = new StringBuffer(512);

      for (int i=0; i <= maxID; i++)
        str.append( i + " : " + names[i] + "\n" );

      return str.toString();
    }

    /** 変数名を保持する配列 */
    private String[] names = new String[INITIAL_CAPACITY];
    /** 最大の変数 ID */
    private int maxID = -1;
        /** その時点までの変数の数を示すID　**/
        private int startID = 0;
    /** 初期変数配列サイズ */
    private final static int INITIAL_CAPACITY = 100;
  }

  /** 節内の変数を管理するためだけの変数テーブル */
  private VarNameTable varNameTable = new VarNameTable();

  /** 記号テーブル */
  private SymbolTable symbolTable = SymbolTable.getSymbolTable();

  /** 項テーブル　*/
  private TermTable termTable = TermTable.getTermTable();

  /** 構文解析中のファイル名 */
  private String fileName = null;

  /** 仮説発見問題の名前 */
  private String problemName = null;

////////////////////////////////////////////////////////////////////////////////
// 仮説発見問題の構文解析
////////////////////////////////////////////////////////////////////////////////

/**
 * 仮説発見問題を構文解析する
 * @param cfp  仮の仮説発見問題
 */
  final public void problem(CFP cfp) throws ParseException {
  Clause inputClause = null;    // 入力節
  Mode inputMode = null;        // 入力宣言
  Pair inputType = null;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CNF:
        inputClause = inputClause();
                                     cfp.addInputClause(inputClause);
        break;
      case HEADMODE:
      case BODYMODE:
        inputMode = inputMode();
                                 cfp.addInputMode(inputMode);
        break;
      case TYPE:
        inputType = inputType();
                                 cfp.addInputTypes(inputType);
        break;
      case INDUCTION_FIELD:
        inductionField(cfp);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CNF:
      case INDUCTION_FIELD:
      case TYPE:
      case HEADMODE:
      case BODYMODE:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
  }

////////////////////////////////////////////////////////////////////////////////
// 別ファイルの読み込み
////////////////////////////////////////////////////////////////////////////////

/**
 * 別ファイルの読み込み
 * @param cfp  仮の仮説発見問題
 */
  final public void include(CFP cfp) throws ParseException {
  Token  fileNameToken = null;    // ファイル名トークン
  String fileName      = null;    // ファイル名
  String fullPath      = null;
    jj_consume_token(INCLUDE);
    jj_consume_token(43);
    fileNameToken = jj_consume_token(FILENAME);
    jj_consume_token(44);
    jj_consume_token(PERIOD);
    try {
      // ファイル名から先頭と末尾の "'" を取り除く
      fileName = fileNameToken.image.substring(1, fileNameToken.image.length() - 1);

      // 指定のファイルを解析する
      new CFParser(fullPath).parse(cfp);

    } catch (FileNotFoundException e) {
      {if (true) throw new ParseException("File '" + fullPath + "' is not found at line " +
                               token.beginLine + ", column " +  token.beginColumn + ".");}
    }
  }

////////////////////////////////////////////////////////////////////////////////
// 入力節の構文解析
////////////////////////////////////////////////////////////////////////////////

/**
 * 入力節の構文解析
 */
  final public Clause inputClause() throws ParseException {
  String name   = null;    // 節の名前
  int    kind   = 0;       // 節の種類
  Clause clause = null;
    jj_consume_token(CNF);
    jj_consume_token(43);
    name = clauseName();
    jj_consume_token(45);
    kind = clauseKind();
    jj_consume_token(45);
    clause = clause(name, kind);
    jj_consume_token(44);
    jj_consume_token(PERIOD);
    {if (true) return clause;}
    throw new Error("Missing return statement in function");
  }

/**
 * 節の名前の構文解析
 */
  final public String clauseName() throws ParseException {
    jj_consume_token(CONSTANT);
               {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

/**
 * 節の種類の構文解析
 */
  final public int clauseKind() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HYPOTHESIS:
      jj_consume_token(HYPOTHESIS);
                   {if (true) return ClauseKind.HYPOTHESIS;}
      break;
    case OBSERVATIONS:
      jj_consume_token(OBSERVATIONS);
                   {if (true) return ClauseKind.OBSERVATIONS;}
      break;
    case BACKGROUND:
      jj_consume_token(BACKGROUND);
                   {if (true) return ClauseKind.BACKGROUND;}
      break;
    case CARC:
      jj_consume_token(CARC);
           {if (true) return ClauseKind.CARC;}
      break;
    case POSITIVE:
      jj_consume_token(POSITIVE);
               {if (true) return ClauseKind.POSITIVE;}
      break;
    case NEGATIVE:
      jj_consume_token(NEGATIVE);
               {if (true) return ClauseKind.NEGATIVE;}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

////////////////////////////////////////////////////////////////////////////////
// 宣言の構文解析
///////////////////////////////////////////////////////////////////////////////


/**
 * 入力宣言の構文解析
 * @param cfp  仮の仮説発見問題
 **/
  final public Mode inputMode() throws ParseException {
  Mode mode = null;                // 宣言
  Token token = null;
  int num = 0;                     // 述語数
  int kind = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HEADMODE:
      jj_consume_token(HEADMODE);
                kind = 0;
      break;
    case BODYMODE:
      jj_consume_token(BODYMODE);
                                           kind = 1;
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(43);
    token = jj_consume_token(CONSTANT);
          num = Integer.parseInt(token.image);
    jj_consume_token(45);
    mode = mode(kind, num);
    jj_consume_token(44);
    jj_consume_token(PERIOD);
   // ヘッド部宣言を返す
        //System.out.println("h1");
        {if (true) return mode;}
    throw new Error("Missing return statement in function");
  }

/**
 * 宣言の構文解析
 * @param cfp 仮の仮説発見問題
 */
  final public Mode mode(int kind, int number) throws ParseException {
   Token name = null; // トークン
   List<MSchema> modeArgs = null;
    name = jj_consume_token(CONSTANT);
    jj_consume_token(43);
    modeArgs = modeArgs();
    jj_consume_token(44);
                {if (true) return Mode.createMode(symbolTable.put(name.image), number, kind, modeArgs);}
    throw new Error("Missing return statement in function");
  }

////////////////////////////////////////////////////////////////////////////////
// 宣言スキーマの構文解析
////////////////////////////////////////////////////////////////////////////////

/**
 * modeArgs は宣言の引数である
 *   宣言スキーマ "," 宣言スキーマ "," ... "," 宣言スキーマ
 */
  final public List<MSchema> modeArgs() throws ParseException {
  MSchema s    = null;               // スキーマ
  List<MSchema> args = new ArrayList<MSchema>();
    s = mSchema();
                   args.add(s);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 45:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      jj_consume_token(45);
      s = mSchema();
        //System.out.println(s);
        args.add(s);
    }
    {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

/**
 * mSchema は 入力項，出力項または定数項である
 */
  final public MSchema mSchema() throws ParseException {
 int kind = 0; //種類
 Token name = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POS:
      jj_consume_token(POS);
           kind = 0;
      break;
    case NEG:
      jj_consume_token(NEG);
                                 kind = 1;
      break;
    case GROUND:
      jj_consume_token(GROUND);
                                                          kind = 2;
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    name = jj_consume_token(CONSTANT);
        //System.out.println(name);
        {if (true) return MSchema.createTerm(symbolTable.put(name.image), kind);}
    throw new Error("Missing return statement in function");
  }

////////////////////////////////////////////////////////////////////////////////
// タイプの構文解析
///////////////////////////////////////////////////////////////////////////////


/**
 * 入力タイプの構文解析
 **/
  final public Pair inputType() throws ParseException {
        Schema term = null;  //項
        Token type = null;
    jj_consume_token(TYPE);
    jj_consume_token(43);
    term = schema();
    jj_consume_token(45);
    type = jj_consume_token(CONSTANT);
    jj_consume_token(44);
    jj_consume_token(PERIOD);
   // タイプを返す
   {if (true) return new Pair(term, new Integer(symbolTable.put(type.image)));}
    throw new Error("Missing return statement in function");
  }

////////////////////////////////////////////////////////////////////////////////
// 節の構文解析
////////////////////////////////////////////////////////////////////////////////

/**
 * 節はリテラルの重複集合である．
 * @param name 節の名前
 * @param kind 節の種類
 * @return 節
 */
  final public Clause clause(String name, int kind) throws ParseException {
        List<Schema>   literals = new ArrayList<Schema>();          // リテラルの集合
        Schema literal  = null;                // リテラル
        // 節内の変数を管理するテーブルを初期化
        varNameTable.clear();
    jj_consume_token(46);
    literal = literal();
                                literals.add(literal);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 45:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      jj_consume_token(45);
      literal = literal();
                                literals.add(literal);
    }
    jj_consume_token(47);
                {if (true) return new Clause(name, kind, literals);}
    throw new Error("Missing return statement in function");
  }

/** 
 * リテラルは，正または負のスキーマである．
 * @return リテラルスキーマ
 */
  final public Schema literal() throws ParseException {
        Token name = null;
        List  args = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTANT:
    case POS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POS:
        jj_consume_token(POS);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      name = jj_consume_token(CONSTANT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 43:
      case 46:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 43:
          jj_consume_token(43);
          break;
        case 46:
          jj_consume_token(46);
          break;
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        args = schemaArgs();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 44:
          jj_consume_token(44);
          break;
        case 47:
          jj_consume_token(47);
          break;
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
                {if (true) return Schema.createPosPredicate(symbolTable.put(name.image), args);}
      break;
    case NEG:
      jj_consume_token(NEG);
      name = jj_consume_token(CONSTANT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 43:
      case 46:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 43:
          jj_consume_token(43);
          break;
        case 46:
          jj_consume_token(46);
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        args = schemaArgs();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 44:
          jj_consume_token(44);
          break;
        case 47:
          jj_consume_token(47);
          break;
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      {if (true) return Schema.createNegPredicate(symbolTable.put(name.image), args);}
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

////////////////////////////////////////////////////////////////////////////////
// スキーマの構文解析
////////////////////////////////////////////////////////////////////////////////

/**
 * schemaArgs は述語もしくは関数の引数である
 *   スキーマ "," スキーマ "," ... "," スキーマ
 */
  final public List schemaArgs() throws ParseException {
  Schema s    = null;               // スキーマ
  List<Schema>   args = new ArrayList<Schema>();
    s = schema();
    args.add(s);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 45:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_4;
      }
      jj_consume_token(45);
      s = schema();
                       args.add(s);
    }
    {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

/**
 * スキーマは以下の形式をしている：
 *   simpleSchema   : 定数 or 変数
 *   compoundSchema : 定数 "(" スキーマ "," ... "," スキーマ ")"
 */
  final public Schema schema() throws ParseException {
  Schema s = null;
    if (jj_2_1(2147483647)) {
      s = compoundSchema();
                                                               {if (true) return s;}
    } else if (jj_2_2(2147483647)) {
      s = listOfSchema();
                                                     {if (true) return s;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SKOLEM:
      case CONSTANT:
      case INTEGER:
      case POS_ACTUAL_NUM:
      case NEG_ACTUAL_NUM:
      case VARIABLE:
      case UNNAMED:
        s = simpleSchema();
                                                     {if (true) return s;}
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * simpleSchema は定数または変数である
 */
  final public Schema simpleSchema() throws ParseException {
  Token name = null;
  Schema s_con = null;
  String skolem = "skolem";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SKOLEM:
    case CONSTANT:
    case INTEGER:
    case POS_ACTUAL_NUM:
    case NEG_ACTUAL_NUM:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SKOLEM:
        name = jj_consume_token(SKOLEM);
        break;
      case CONSTANT:
        name = jj_consume_token(CONSTANT);
        break;
      case INTEGER:
        name = jj_consume_token(INTEGER);
        break;
      case POS_ACTUAL_NUM:
        name = jj_consume_token(POS_ACTUAL_NUM);
        break;
      case NEG_ACTUAL_NUM:
        name = jj_consume_token(NEG_ACTUAL_NUM);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        if(name.image.equals(skolem)){
                        s_con = Schema.createSkolem(symbolTable.put(name.image));
                }
                else{
                        s_con = Schema.createConstant(symbolTable.put(name.image));
        }
        termTable.put(s_con);
                {if (true) return s_con;}
      break;
    case VARIABLE:
      name = jj_consume_token(VARIABLE);
    {if (true) return Schema.createVariable(varNameTable.put(name.image));}
      break;
    case UNNAMED:
      name = jj_consume_token(UNNAMED);
    {if (true) return Schema.createVariable(varNameTable.put());}
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * compoundSchema は述語もしくは関数である
 */
  final public Schema compoundSchema() throws ParseException {
        Token name = null;
        List  args = null;
    name = jj_consume_token(CONSTANT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      break;
    case 46:
      jj_consume_token(46);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    args = schemaArgs();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 44:
      jj_consume_token(44);
      break;
    case 47:
      jj_consume_token(47);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                Schema s_func = Schema.createFunction(symbolTable.put(name.image), args);
                termTable.put(s_func);
                {if (true) return s_func;}
    throw new Error("Missing return statement in function");
  }

/**
 * listOfSchema は schema のリストである
 */
  final public Schema listOfSchema() throws ParseException {
  LinkedList<Schema> list = new LinkedList<Schema>();
  Schema     tail = null;
    if (jj_2_3(2147483647)) {
      jj_consume_token(46);
      jj_consume_token(47);
    {if (true) return Schema.createConstant(symbolTable.put("[]"));}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 46:
        jj_consume_token(46);
        listOfSchemaAux(list);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 48:
          jj_consume_token(48);
          tail = schema();
          break;
        default:
          jj_la1[21] = jj_gen;
          ;
        }
        jj_consume_token(47);
    if (tail != null)
      list.add(tail);
    else
      list.add(Schema.createConstant(symbolTable.put("[]")));

    LinkedList<Schema> args = new LinkedList<Schema>();
    args.addFirst(list.removeLast());
    args.addFirst(list.removeLast());
    Schema s = Schema.createFunction(symbolTable.put("."), args);

    while (!list.isEmpty()) {
      args.clear();
      args.addFirst(s);
      args.addFirst(list.removeLast());
      s = Schema.createFunction(symbolTable.put("."), args);
    }

    {if (true) return s;}
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * listOfSchemaAux は，１つ以上の schema のリストである
 */
  final public void listOfSchemaAux(List<Schema> list) throws ParseException {
  Schema s1 = null;
  Schema s2 = null;
    s1 = schema();
    list.add(s1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 45:
      jj_consume_token(45);
      listOfSchemaAux(list);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
  }

////////////////////////////////////////////////////////////////////////////////
// 仮説発見領域の構文解析
///////////////////////////////////////////////////////////////////////////////

/**
 * 仮説発見領域の構文解析
 * @param cfp  仮の仮説発見問題
 */
  final public void inductionField(CFP cfp) throws ParseException {
  Token           begin           = null;                             // 開始行
  InductionField inductionField = new InductionField();
    begin = jj_consume_token(INDUCTION_FIELD);
    jj_consume_token(43);
    inductionFieldArgs(inductionField);
    jj_consume_token(44);
    jj_consume_token(PERIOD);
    // すでに仮説発見領域の指定がある場合は，エラーとする
    if (cfp.getInductionField() != null)
      {if (true) throw new ParseException("Redeclaration of induction field at line " + begin.beginLine + " :\n" +
                               "  " + inductionField);}

    // 仮説発見領域の登録
    cfp.setInductionField(inductionField);
  }

/**
 * 仮説発見領域の引数の構文解析
 * @param inductionField  仮説発見領域
 */
  final public void inductionFieldArgs(InductionField inductionField) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LENGTH:
      getLength(inductionField);
      break;
    case SIZE:
      getSize(inductionField);
      break;
    case 46:
      indPredicates(inductionField);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 45:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_5;
      }
      jj_consume_token(45);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LENGTH:
        getLength(inductionField);
        break;
      case SIZE:
        getSize(inductionField);
        break;
      case 46:
        indPredicates(inductionField);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/**
 * 仮説の最大長制限の構文解析
 * @param inductionField  生成領域
 */
  final public void getLength(InductionField inductionField) throws ParseException {
 Token tokenMax = null;
 Token tokenMin = null;
    jj_consume_token(LENGTH);
    jj_consume_token(46);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTANT:
      tokenMin = jj_consume_token(CONSTANT);
      jj_consume_token(49);
                                        inductionField.setMinLength(Integer.parseInt(tokenMin.image));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONSTANT:
        tokenMax = jj_consume_token(CONSTANT);
                                inductionField.setMaxLength(Integer.parseInt(tokenMax.image));
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      break;
    case 49:
      jj_consume_token(49);
      tokenMax = jj_consume_token(CONSTANT);
                                      inductionField.setMaxLength(Integer.parseInt(tokenMax.image));
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(47);
  }

/**
 * 仮説の最大節数制限の構文解析
 * @param inductionField  生成領域
 */
  final public void getSize(InductionField inductionField) throws ParseException {
 Token tokenMax = null;
 Token tokenMin = null;
    jj_consume_token(SIZE);
    jj_consume_token(46);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTANT:
      tokenMin = jj_consume_token(CONSTANT);
      jj_consume_token(49);
                                        inductionField.setMinSize(Integer.parseInt(tokenMin.image));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONSTANT:
        tokenMax = jj_consume_token(CONSTANT);
                                inductionField.setMaxSize(Integer.parseInt(tokenMax.image));
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      break;
    case 49:
      jj_consume_token(49);
      tokenMax = jj_consume_token(CONSTANT);
                                      inductionField.setMaxSize(Integer.parseInt(tokenMax.image));
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(47);
  }

/**
 * 述語指定の構文解析
 * @param inductionField  生成領域
 */
  final public void indPredicates(InductionField inductionField) throws ParseException {
    jj_consume_token(46);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
      jj_consume_token(ALL);
               inductionField.allowAllPredicates();
      break;
    case POS_ALL:
      jj_consume_token(POS_ALL);
               inductionField.allowAllPosPredicates();
      break;
    case NEG_ALL:
      jj_consume_token(NEG_ALL);
               inductionField.allowAllNegPredicates();
      break;
    case CONSTANT:
    case POS:
    case NEG:
    case POS_NEG:
      indPredicate(inductionField);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 45:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_6;
        }
        jj_consume_token(45);
        indPredicate(inductionField);
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(47);
  }

/**
 * 仮説発見領域の述語の構文解析
 * @param inductionField  仮説発見領域
 */
  final public void indPredicate(InductionField inductionField) throws ParseException {
        Token   name    = null;    // 名前
    Schema   schema  = null;    // 生成領域で指定される述語
        List    args    = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTANT:
    case POS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POS:
        jj_consume_token(POS);
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      name = jj_consume_token(CONSTANT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 43:
        jj_consume_token(43);
        args = schemaArgs();
        jj_consume_token(44);
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      schema = Schema.createPosPredicate(symbolTable.put(name.image), args);
      inductionField.addPredicate(schema);
      break;
    case NEG:
      jj_consume_token(NEG);
      name = jj_consume_token(CONSTANT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 43:
        jj_consume_token(43);
        args = schemaArgs();
        jj_consume_token(44);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      schema = Schema.createNegPredicate(symbolTable.put(name.image), args);
      inductionField.addPredicate(schema);
      break;
    case POS_NEG:
      jj_consume_token(POS_NEG);
      name = jj_consume_token(CONSTANT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 43:
        jj_consume_token(43);
        args = schemaArgs();
        jj_consume_token(44);
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      schema = Schema.createPosNegPredicate(symbolTable.put(name.image), args);
      inductionField.addPredicate(schema);
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(46)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(CONSTANT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) return true;
    }
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(46)) return true;
    if (jj_scan_token(47)) return true;
    return false;
  }

  public CFParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[38];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x1448200,0x1448200,0x6007800,0x1400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0xf8800000,0x78800000,0xf8800000,0x0,0x0,0x0,0x0,0x0,0x30000,0x0,0x30000,0x8000000,0x8000000,0x8000000,0x8000000,0x0,0x8380000,0x0,0x0,0x0,0x0,0x8000000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x2000,0x160,0x2000,0x20,0x4800,0x9000,0x4800,0x4800,0x9000,0x4800,0x60,0x2000,0x1,0x0,0x1,0x4800,0x9000,0x10000,0x4000,0x2000,0x4000,0x2000,0x4000,0x0,0x20000,0x0,0x20000,0x2000,0xe0,0x20,0x800,0x800,0x800,0xe0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[3];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public CFParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public CFParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CFParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public CFParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new CFParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public CFParser(CFParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(CFParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[50];
    for (int i = 0; i < 50; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 38; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 50; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 3; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
